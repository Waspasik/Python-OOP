# Класс ReversibleString
# Реализуйте класс ReversibleString, описывающий строку. При создании экземпляра класс должен
# принимать один аргумент:

# string — значение строки

# Экземпляр класса ReversibleString должен иметь следующее неформальное строковое представление:

# <значение строки>

# Также экземпляр класса ReversibleString должен поддерживать унарный оператор -, результатом
# которого должен являться новый экземпляр класса ReversibleString со значением строки в обратном
# порядке.

class ReversibleString:
    def __init__(self, string):
        self.string = string
    
    def __str__(self):
        return self.string
    
    def __neg__(self):
        return ReversibleString(self.string[::-1])



# Класс Money
# Реализуйте класс Money, описывающий денежную сумму в рублях. При создании экземпляра класс
# должен принимать один аргумент:

# amount — количество денег

# Экземпляр класса Money должен иметь следующее неформальное строковое представление:

# <количество денег> руб.

# Также экземпляр класса Money должен поддерживать унарные операторы + и -:

# результатом унарного + должен являться новый экземпляр класса Money с неотрицательным количеством
# денег
# результатом унарного - должен являться новый экземпляр класса Money с отрицательным количеством
# денег

class Money:
    def __init__(self, amount):
        self.amount = amount
    
    def __str__(self):
        return f"{self.amount} руб."
    
    def __pos__(self):
        return Money(abs(self.amount))
            
    def __neg__(self):
        return Money(-abs(self.amount))



# Класс Vector
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен
# принимать два аргумента в следующем порядке:

# x — координата вектора по оси x
# y — координата вектора по оси y

# Экземпляр класса Vector должен иметь следующее формальное строковое представление:

# Vector(<координата x>, <координата y>)

# И следующее неформальное строковое представление:

# (<координата вектора по оси x>, <координата вектора по оси y>)

# Также экземпляр класса Vector должен поддерживать унарные операторы + и -:

# результатом унарного + должен являться новый экземпляр класса Vector с исходными координатами
# результатом унарного - должен являться новый экземпляр класса Vector с координатами, взятыми с
# противоположным знаком

# Наконец, при передаче экземпляра класса Vector в функцию abs() должен возвращаться его модуль.

from math import sqrt


class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __pos__(self):
        return Vector(self.x, self.y)
            
    def __neg__(self):
        return Vector(-self.x, -self.y)
    
    def __abs__(self):
        f = sqrt(self.x**2 + self.y**2)
        return abs(f)



# Класс ColoredPoint
# Реализуйте класс ColoredPoint, описывающий цветную точку на плоскости. При создании экземпляра
# класс должен принимать три аргумента в следующем порядке:

# x — координата точки по оси x
# y — координата точки по оси y
# color — цвет в формате RGB, представленный кортежем из трех целых чисел в диапазоне [0; 255],
# по умолчанию имеет значение (0, 0, 0)

# Экземпляр класса ColoredPoint должен иметь три атрибута:

# x — координата точки по оси x
# y — координата точки по оси y
# color — цвет в формате RGB, представленный кортежем из трех целых чисел от 0 до 255

# Также экземпляр класса ColoredPoint должен иметь следующее формальное строковое представление:

# ColoredPoint(<координата x>, <координата y>, <цвет точки в виде трехэлементного кортежа>)

# И следующее неформальное строковое представление:

# (<координата x>, <координата y>)

# Наконец, экземпляр класса ColoredPoint должен поддерживать унарные операторы +, - и ~:

# результатом унарного + должен являться новый экземпляр класса ColoredPoint c исходными координатами
# и цветом
# результатом унарного - должен являться новый экземпляр класса ColoredPoint c координатами,
# умноженными на минус единицу, и исходным цветом
# результатом унарного ~ должен являться новый экземпляр класса ColoredPoint c координатами,
# переставленными местами, и инвертированным цветом: значение каждой компоненты цвета отнимается
# от 255

class ColoredPoint:
    def __init__(self, x, y, color=(0, 0, 0)):
        self.x = x
        self.y = y
        self.color = color
    
    def __str__(self):
        return f"({self.x}, {self.y})"
    
    def __repr__(self):
        return f"ColoredPoint({self.x}, {self.y}, {self.color})"
    
    def __pos__(self):
        return ColoredPoint(self.x, self.y, self.color)
            
    def __neg__(self):
        return ColoredPoint(-self.x, -self.y, self.color)
    
    def __invert__(self):
        new_color = tuple(map(lambda x: 255 - x, self.color))
        return ColoredPoint(self.y, self.x, new_color)

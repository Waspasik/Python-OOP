# Класс Calculator
# Реализуйте класс Calculator, экземпляры которого позволяют выполнять различные арифметические
# операции с двумя числами. При создании экземпляра класс не должен принимать никаких аргументов.

# Экземпляр класса Calculator должен являться вызываемым объектом и принимать три аргумента:

# a — число
# b — число
# operation — один из символов +, -, * и /

# Если operation равняется +, экземпляр класса Calculator должен вернуть сумму a и b, если - —
# разность a и b, если * — произведение a и b, если / — частное a и b. При попытке выполнить
# деление на ноль должно быть возбуждено исключение ValueError с текстом:

# Деление на ноль невозможно

# Примечание 1. Числами будет считать экземпляры классов int и float.

class Calculator:
    def __call__(self, a, b, operation):
        try:
            return eval(f'{a} {operation} {b}')
        except:
            raise ValueError('Деление на ноль невозможно')



# Класс RaiseTo
# Реализуйте класс RaiseTo, экземпляры которого позволяют возводить числа в фиксированную
# степень. При создании экземпляра класс должен принимать один аргумент:

# degree — показатель степени

# Экземпляр класса RaiseTo должен являться вызываемым объектом и принимать один аргумент:

# x — число

# Экземпляр класса RaiseTo должен возвращать значение x в степени degree.

class RaiseTo:
    def __init__(self, degree):
        self.degree = degree
    
    def __call__(self, x):
        return x**self.degree
    


# Класс Dice
# Реализуйте класс Dice, описывающий игральный кубик с определенным количеством граней. При
# создании экземпляра класс должен принимать один аргумент:

# sides — количество граней игрального кубика

# Экземпляр класса Dice должен являться вызываемым объектом и не принимать никаких аргументов.
# При вызове он должен возвращать значение случайной грани игрального кубика. Например, если
# кубик имеет 6 граней, экземпляр класса Dice должен вернуть случайное число из диапазона [1; 6].

from random import randint


class Dice:
    def __init__(self, sides):
        self.sides = sides
    
    def __call__(self):
        return randint(1, self.sides)



# Класс QuadraticPolynomial
# Реализуйте класс QuadraticPolynomial, описывающий квадратный трехчлен. При создании экземпляра
# класс должен принимать три аргумента в следующем порядке:

# a — коэффициент a квадратного трехчлена
# b — коэффициент b квадратного трехчлена
# c — коэффициент c квадратного трехчлена

# Экземпляр класса QuadraticPolynomial должен являться вызываемым объектом и принимать один
# аргумент:

# x — число

# Экземпляр класса QuadraticPolynomial должен возвращать значение выражения ax^2 + bx + c, где 
# a, b и c — коэффициенты квадратного трехчлена.

class QuadraticPolynomial:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
    
    def __call__(self, x):
        return eval(f"{self.a * x**2} + {self.b * x} + {self.c}")



# Класс Strip
# Реализуйте класс Strip, экземпляры которого позволяют удалять из начала и конца строки
# определенные символы. При создании экземпляра класс должен принимать один аргумент:

# chars — строка, в которой перечислены удаляемые символы

# Экземпляр класса Strip должен являться вызываемым объектом и принимать один аргумент:

# string — строка

# Экземпляр класса Strip должен удалять из начала и конца строки string все символы,
# перечисленные в chars, и возвращать полученный результат.

class Strip:
    def __init__(self, chars):
        self.chars = chars
    
    def __call__(self, string):
        return string.strip(self.chars)



# Класс Filter
# Реализуйте класс Filter, описывающий объект для фильтрации элементов итерируемых объектов.
# При создании экземпляра класс должен принимать один аргумент:

# predicate — функция-предикат; если имеет значение None, то работает аналогично функции bool()

# Экземпляр класса Filter должен являться вызываемым объектом и принимать один аргумент:

# iterable — итерируемый объект

# Экземпляр класса Filter должен возвращать список, элементами которого являются элементы
# итерируемого объекта iterable, для которых функция predicate вернула значение True.

# Примечание 1. Предикат — это функция, которая возвращает True или False в зависимости от
# переданного в качестве аргумента значения.

class Filter:
    def __init__(self, func):
        self.predicate = func or bool
    
    def __call__(self, iterable):
        return list(filter(lambda x: self.predicate(x), iterable))



# Класс DateFormatter
# Реализуйте класс DateFormatter, экземпляры которого позволяют преобразовывать даты в формат
# определенной страны из таблицы выше. При создании экземпляра класс должен принимать один
# аргумент:

# country_code — код страны

# Экземпляр класса DateFormatter должен являться вызываемым объектом и принимать один аргумент:

# d — дата (тип date)

# Экземпляр класса DateFormatter должен возвращать строку с датой d в формате страны с кодом
# country_code.

from datetime import datetime


class DateFormatter:
    def __init__(self, country_code):
        self.country_code = country_code
        self._format_date = {
            "ru": r"%d.%m.%Y",
            "us": r"%m-%d-%Y",
            "ca": r"%Y-%m-%d",
            "br": r"%d/%m/%Y",
            "fr": r"%d.%m.%Y",
            "pt": r"%d-%m-%Y"
        }
    
    def __call__(self, d):
        return datetime.strftime(d, self._format_date[self.country_code])



# Декоратор @CountCalls
# Реализуйте декоратор @CountCalls, который считает количество вызовов декорируемой функции.
# Счетчик вызовов должен быть доступен по атрибуту calls.

# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение
# декорируемой функции, а также должен уметь декорировать функции с произвольным количеством
# позиционных и именованных аргументов.

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимый декоратор
# @CountCalls, но не код, вызывающий его.

class CountCalls:
    def __init__(self, func):
        self.func = func
        self.calls = 0
 
    def __call__(self, *args, **kwargs):
        self.calls += 1
        return self.func(*args, **kwargs)
